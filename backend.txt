For your UzimaCare project (digital healthcare referral system with physician → admin → payment → completion flow, planned AI integration, real MySQL database, real-time-ish fetching), here's a clear, practical breakdown in 2026 context.
Next.js (App Router) is already a very capable full-stack framework — it can handle almost everything you need for a production MVP + early growth phase. However, there are still good reasons to split certain pieces into separate Node.js + Express microservices (especially once AI and heavy backend logic enter the picture).
Services / Features Best Implemented Inside Next.js (Recommended Core)
These are the pieces that benefit most from staying in the same codebase: fast iteration, shared types (TypeScript), single deployment (Vercel), automatic SSR/edge caching, and tight frontend-backend integration.




Backend Integration Breakdown (Next.js + NestJS + Express Microservice)
1. Main Backend (Core of the App) – Pure Next.js (App Router) + Prisma + MySQL
This will handle 90–95% of your current needs for the hackathon MVP (and even early production).
What it will do:

User authentication (login/logout for physician, admin, future patient)
All CRUD operations: referrals, bookings, users, tokens, biodata, payments
STK prompt initiation (real Safaricom Daraja API integration)
Status transitions (pending-admin → awaiting-biodata → pending-payment → paid/completed)
Real-time feel via polling or basic Server-Sent Events (SSE)
Basic notifications (in-app bell, future SMS/email triggers)

Why Next.js is perfect here:

Single codebase → fast development
Server Components + Route Handlers = no extra server needed
Prisma gives type-safe, auto-migrated MySQL database
Deploy to Vercel → free, fast, auto-scaling

Tech stack:

Next.js 14/15 (App Router)
Prisma + MySQL (PlanetScale or local MySQL)
Auth.js (NextAuth) or Lucia for authentication
Route Handlers (app/api/.../route.ts) for API endpoints

2. NestJS Part (Optional but recommended later)
NestJS is not needed right now for the hackathon MVP.
But if you want a more structured, scalable backend after the hackathon, you can migrate the core logic to NestJS (still inside the same Next.js monorepo or separate).
When to use NestJS:

After MVP, when you have:
Many endpoints
Complex business rules (billing, multi-facility, compliance)
Need for strong typing, DI, modules, guards, interceptors

You like clean architecture (controllers, services, modules)

How it fits:

You can run NestJS as a separate service (port 3001) or inside Next.js (via custom server – but not recommended)
Next.js frontend calls NestJS APIs via HTTP

Simple plan for later:
text/api-core (NestJS)
├── src/
│   ├── auth/
│   ├── referrals/
│   ├── payments/
│   ├── users/
│   └── main.ts
└── prisma/
3. Express Microservice (For AI & Heavy Tasks – Future)
This is only for after the hackathon when you add real AI features.
What it will do:

AI-powered referral analysis (triage priority, summarize history, suggest diagnosis)
Batch processing (nightly reports, reminders queue)
Heavy file processing (lab PDFs, future image analysis)

Why separate Express (or FastAPI) microservice:

Long-running tasks → no Vercel timeout (60s hobby → 300s pro)
GPU support possible (if you host your own model)
Independent scaling & deployment

Simple structure (after MVP):
text/ai-service (Express or NestJS)
├── src/
│   ├── routes/
│   │   └── analyze.ts   // POST /analyze → calls your AI model
│   ├── services/
│   │   └── ai.service.ts
│   └── server.ts
└── .env (AI API keys, model endpoints)
Communication:

Next.js backend → calls AI microservice via internal HTTP (e.g., http://ai-service:3002/analyze)
Or use message queue (Redis + BullMQ) for async jobs

Summary – Timeline Recommendation

























PhaseBackend ChoiceWhen to BuildNow – Hackathon MVPPure Next.js + Prisma + MySQLImmediate priorityAfter hackathonNestJS for core APIWhen MVP is stable (March+)AI & heavy tasksExpress / FastAPI microserviceWhen you integrate real AI model






















































Service / CapabilityWhy keep it in Next.js?How to implement (2026 best practice)Priority for your projectAuthentication & sessionsBuilt-in middleware, Server Actions, secure cookies, easy integration with frontendNextAuth.js v5 / Auth.js, Lucia, Clerk, Supabase Auth, or self-hosted JWT in middlewareHigh (must-have)CRUD for referrals, users, bookingsFast prototyping, direct Server Component / Server Action usage, no extra network hopRoute Handlers (app/api/referrals/route.ts) + Prisma/MySQLHighBasic business logicReferral status transitions, token generation, priority rules, biodata validationServer Actions or Route HandlersHighPayment initiation (STK prompt)Quick simulation → real Daraja API integration, secure key storage on serverRoute Handler that calls Safaricom Daraja APIHighSimple notifications & remindersPolling or basic SSE, in-app bell, email/SMS triggersServer Actions + Upstash Redis / Resend / Novu (if needed)MediumUI data fetching & renderingDirect DB queries in Server Components, no client ↔ server roundtripsServer Components + PrismaHighRate limiting, basic loggingBuilt-in middleware supportNext.js middleware + Upstash Rate LimitMediumSEO, metadata, static pagesNative support (if you add public landing page later)generateMetadata, static renderingLow-Medium
→ ~80–90% of your current MVP + near-term features belong here.
Features / Microservices Best Implemented Separately with Node.js + Express (Recommended Split)
These are the pieces that become painful, risky, or inefficient when forced into Next.js's serverless/edge model.






















































Microservice / Bounded ContextWhy separate (Express / NestJS / Fastify)?Typical tech stack choices (2026)When to actually build it (timeline)Priority for UzimaCare nowHeavy / long-running AI inferenceNext.js functions have timeouts (Vercel: 60s hobby → 300s pro), cold starts hurt latency, GPU not nativeExpress + FastAPI (Python) / NestJS + LangChain / Llama.cpp / vLLM / OllamaAfter MVP — when real AI triage / summarization / diagnosis assist is liveMedium (future)Batch jobs & background processingCron jobs, email queues, referral reminders at scale, PDF report generation, nightly analyticsBullMQ / Bee-Queue + Redis, NestJS scheduled tasksWhen reminders / reports / analytics become realLow now → Medium laterComplex / multi-tenant domain logicFacility management, billing across hospitals, audit trails, compliance rules (NHIF / data protection)NestJS (strong DI, modules, decorators)When multi-facility + billing is addedLow nowHigh-throughput / real-time APIsIf you later add chat between facilities, live tracking, or very high TPS endpointsExpress/NestJS + WebSockets (Socket.io) or SSEOnly if polling becomes bottleneckLowPublic / third-party APIExposing endpoints to mobile apps, partner systems, or external AI services without frontend couplingExpress with OpenAPI/Swagger, rate limiting, API keysWhen you build mobile companion appLow-Medium (future)Heavy compute / file processingLarge lab result PDFs, image analysis (if AI does X-ray / scan triage)Dedicated service + queueOnly if file uploads + AI analysisLow now
Recommended Architecture for Your Project (Jan–Feb 2026 Timeline)
Phase 1 – Now until submission (Feb 19) → Pure Next.js full-stack (strongly recommended)

Database → Prisma + MySQL (local or PlanetScale free tier)
All APIs → Route Handlers (app/api/...)
Data fetching → Server Components + Server Actions where possible
Auth → Auth.js / Lucia / simple JWT in cookies
Payment → Daraja sandbox in Route Handler
Real-time feel → polling (setInterval 5–10s) or very basic SSE
Deployment → Vercel (free tier handles this perfectly)

→ You get a clean, fast-moving MVP with real DB persistence, no CORS headaches, single repo/deploy.
Phase 2 – After hackathon / when AI becomes real (March–June 2026)
Split into 1–2 microservices only when pain appears:

AI Service (highest priority split)
Node.js + Express (or FastAPI if model is Python-based)
Endpoints: /analyze-referral, /summarize-history, /suggest-priority
Called from Next.js backend via internal HTTP (not exposed publicly)

Background Jobs Service (if reminders/reports grow)
NestJS or BullMQ on Express
Redis for queue


Everything else (referrals CRUD, admin actions, payment flow) stays in Next.js — it's more than capable.
Summary Advice for Your Project Right Now

Do not create a separate Express backend yet — it will slow you down dramatically for the hackathon.
Do move to Prisma + MySQL inside Next.js this week — that's the single biggest upgrade you can make right now (real persistence, relations, migrations, type-safety).
Keep AI integration very simple for MVP: mock it or call external API (Groq / OpenAI) from a Next.js Route Handler.

If you want, we can start right now with:

Setting up Prisma + MySQL (local or PlanetScale)
Migrating your db.referrals Map logic to Prisma models
Creating first Route Handler for referrals

Which of those three sounds most useful as the next step?